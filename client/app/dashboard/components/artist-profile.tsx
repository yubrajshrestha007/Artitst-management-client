// /home/mint/Desktop/ArtistMgntFront/client/app/dashboard/components/artist-profile.tsx
"use client";
import { useState, useMemo, useCallback, useEffect } from "react";
import { ArtistProfile } from "@/shared/queries/artist-profile";
// Removed useUsersQuery, useArtistProfileByUserIdQuery as data fetching moves to parent
import { useDeleteArtistProfileMutation } from "@/shared/queries/artist-profile";
import { toast } from "sonner";
import { fetchManagers } from "@/shared/queries/manager-profile";
import { useQueryClient } from "@tanstack/react-query"; // Keep for delete invalidation if needed

interface ArtistProfileFormProps {
  onSubmit: (data: Partial<ArtistProfile>) => void; // Allow partial for creation/update
  initialData?: ArtistProfile | null; // Make it explicitly nullable
  currentUserId?: string | null; // Pass currentUserId as prop if needed for creation submit
  onCancel?: () => void; // Optional cancel handler
  onDeleteSuccess?: () => void; // Optional callback after successful delete
}

// Default form data for a new artist profile (excluding fields generated by backend)
const defaultFormData: Omit<ArtistProfile, 'id' | 'user_id'> = {
  name: "",
  date_of_birth: null,
  gender: "",
  address: "",
  first_release_year: null,
  no_of_albums_released: 0,
  manager_id_id: null,
};

export default function ArtistProfileForm({
  onSubmit,
  initialData,
  currentUserId, // Receive from parent
  onCancel,
  onDeleteSuccess,
}: ArtistProfileFormProps) {
  const queryClient = useQueryClient();
  // Initialize form state based on initialData or default
  const [formData, setFormData] = useState<Partial<ArtistProfile>>(
      initialData ? { ...initialData } : { ...defaultFormData }
  );
  const [isDeleting, setIsDeleting] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  // Keep track of the initially assigned manager ID from initialData
  const [initialManagerId, setInitialManagerId] = useState<string | null>(
      initialData?.manager_id_id || null
  );
  const [allManagers, setAllManagers] = useState<{ id: string; name: string }[]>([]);
  const [isLoadingManagers, setIsLoadingManagers] = useState(true);
  const [isManagerError, setIsManagerError] = useState(false);

  // Determine if we are in "update" mode based on initialData having an ID
  const isUpdateMode = !!initialData?.id;

  // Function to reset the form data to default values
  const resetFormData = useCallback(() => {
    console.log("Resetting form data in ArtistProfileForm");
    setFormData({ ...defaultFormData });
    setInitialManagerId(null);
  }, []);

  // Effect to reset form when initialData changes (e.g., after delete or switching profiles)
  useEffect(() => {
    console.log("ArtistProfileForm initialData changed:", initialData);
    if (initialData) {
      // Ensure all fields from initialData are set, even if null
      const dataToSet = { ...defaultFormData, ...initialData };
      setFormData(dataToSet);
      setInitialManagerId(initialData.manager_id_id || null);
    } else {
      resetFormData();
    }
  }, [initialData, resetFormData]);


  // Delete Mutation - Handles invalidation and state reset on success
  const { mutate: deleteArtistProfile } = useDeleteArtistProfileMutation({
    onSuccess: () => {
      toast.success("Artist profile deleted successfully");
      // Invalidate the specific query in the parent via queryClient
      if (currentUserId) {
         queryClient.invalidateQueries({
            queryKey: ['artistProfileByUserId', currentUserId.toString()]
         });
      } else {
         // Fallback or broader invalidation if needed
         queryClient.invalidateQueries({ queryKey: ['artistProfileByUserId'] });
         queryClient.invalidateQueries({ queryKey: ['artist-profiles'] }); // Invalidate list too
      }
      resetFormData(); // Reset form state within this component
      setIsDeleting(false);
      onDeleteSuccess?.(); // Call parent callback if provided
    },
    onError: (error) => {
      toast.error(`Error deleting artist profile: ${error.message}`);
      setIsDeleting(false); // Ensure deleting state is reset on error too
    },
  });

  // Memoize fetchManagers
  const memoizedFetchManagers = useMemo(() => fetchManagers, []);

  // Fetch managers only once when the component mounts
  useEffect(() => {
    const loadManagers = async () => {
      setIsLoadingManagers(true);
      setIsManagerError(false);
      try {
        const managersResult = await memoizedFetchManagers();
        if (managersResult && Array.isArray(managersResult)) {
          setAllManagers(
            managersResult.map((manager) => ({
              id: manager.id || "",
              name: manager.name || "Unnamed Manager", // Provide default name
            })).filter(manager => manager.id) // Filter out managers without valid IDs
          );
        } else {
          console.warn("fetchManagers did not return a valid array:", managersResult);
          setAllManagers([]);
        }
      } catch (error) {
        setIsManagerError(true);
        toast.error("Error loading managers.");
        console.error("Manager fetch error:", error);
        setAllManagers([]);
      } finally {
        setIsLoadingManagers(false);
      }
    };
    loadManagers();
  }, [memoizedFetchManagers]); // Only depends on the memoized function


  const handleChange = useCallback(
    (
      e: React.ChangeEvent<
        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
      >
    ) => {
      const { name, value } = e.target;
      const target = e.target as HTMLInputElement; // Type assertion for easier access

      let processedValue: string | number | boolean | null = value;

      if (target.type === 'number') {
          processedValue = value === '' ? null : Number(value);
      } else if (target.type === 'checkbox') {
          processedValue = target.checked;
      } else if (target.type === 'date') {
          // Keep as string, backend should handle parsing
          processedValue = value === '' ? null : value;
      }

      setFormData((prevFormData) => ({
        ...prevFormData,
        [name]: processedValue,
      }));
    },
    []
  );

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      setIsSubmitting(true);
      try {
        // Manager ID logic remains similar, based on initial load vs. selection
        const managerIdToSubmit = initialManagerId || formData.manager_id_id;

        // Prepare data, include id only if updating
        const dataToSubmit: Partial<ArtistProfile> = {
          ...formData,
          manager_id_id: managerIdToSubmit,
        };

        // Clean up fields not needed for create/update if necessary
        // delete dataToSubmit.user; // Example if user object is included

        if (isUpdateMode && initialData?.id) {
           dataToSubmit.id = initialData.id; // Add id for update
           // Ensure user_id is not sent on update if backend doesn't expect it
           delete dataToSubmit.user_id;
        } else if (!isUpdateMode && currentUserId) {
           dataToSubmit.user_id = currentUserId; // Add user_id for create
           // Ensure id is not sent on create
           delete dataToSubmit.id;
        } else if (!isUpdateMode && !currentUserId) {
            toast.error("Cannot create profile: User ID is missing.");
            setIsSubmitting(false);
            return; // Prevent submission
        }

        console.log("Submitting from ArtistProfileForm:", dataToSubmit);
        await onSubmit(dataToSubmit); // Call the onSubmit passed from parent
        // Success toast should be handled in the parent's mutation onSuccess

      } catch (error: any) {
        console.error("Submit error in ArtistProfileForm:", error);
        toast.error(`Error submitting the form: ${error.message || 'Unknown error'}`);
      } finally {
        setIsSubmitting(false);
      }
    },
    [
      formData,
      initialData, // Use initialData directly
      isUpdateMode,
      currentUserId,
      initialManagerId,
      onSubmit,
    ]
  );

  const handleDelete = useCallback(async () => {
    // ID comes only from initialData
    const idToDelete = initialData?.id;
    if (idToDelete) {
      setIsDeleting(true);
      deleteArtistProfile(idToDelete); // Call the mutation
    } else {
       toast.error("No valid ID found to delete the artist profile.");
    }
  }, [initialData?.id, deleteArtistProfile]);

  // Determine the current manager's name
  const currentManagerName = useMemo(() => {
    // Use initialManagerId derived from initialData
    if (!initialManagerId || !allManagers.length) return "No Manager Assigned";
    const manager = allManagers.find((m) => m.id === initialManagerId);
    return manager ? manager.name : "Manager Not Found";
  }, [initialManagerId, allManagers]);


  // Loading state now only depends on managers
  if (isLoadingManagers) {
    return <div className="p-4 text-center text-gray-500">Loading manager options...</div>;
  }
  // Removed isLoadingProfile check

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-4 p-4 border rounded-md bg-white shadow-sm">
      {/* --- Form Fields --- */}
      {/* Name */}
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">Name</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name || ""}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          required
        />
      </div>
      {/* Date of Birth */}
      <div>
        <label htmlFor="date_of_birth" className="block text-sm font-medium text-gray-700 mb-1">Date of Birth</label>
        <input
          type="date"
          id="date_of_birth"
          name="date_of_birth"
          // Format date for input value if it's a Date object, otherwise use string/null
          value={typeof formData.date_of_birth === "string" && !isNaN(Date.parse(formData.date_of_birth))
                 ? new Date(formData.date_of_birth).toISOString().split('T')[0]
                 : formData.date_of_birth || ""}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
        />
      </div>
      {/* Gender */}
      <div>
        <label htmlFor="gender" className="block text-sm font-medium text-gray-700 mb-1">Gender</label>
        <select
          id="gender"
          name="gender"
          value={formData.gender || ""}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          required
        >
          <option value="">Select Gender</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="other">Other</option>
        </select>
      </div>
      {/* Address */}
      <div>
        <label htmlFor="address" className="block text-sm font-medium text-gray-700 mb-1">Address</label>
        <input
          type="text"
          id="address"
          name="address"
          value={formData.address || ""}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
        />
      </div>
      {/* First Release Year */}
      <div>
        <label htmlFor="first_release_year" className="block text-sm font-medium text-gray-700 mb-1">First Release Year</label>
        <input
          type="number"
          id="first_release_year"
          name="first_release_year"
          value={formData.first_release_year ?? ""}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          min="1900"
          max={new Date().getFullYear()}
        />
      </div>
      {/* No. of Albums Released */}
      <div>
        <label htmlFor="no_of_albums_released" className="block text-sm font-medium text-gray-700 mb-1">No. of Albums Released</label>
        <input
          type="number"
          id="no_of_albums_released"
          name="no_of_albums_released"
          value={formData.no_of_albums_released ?? 0}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          min="0"
        />
      </div>

      {/* Manager Section */}
      <div>
        <label htmlFor="manager_id" className="block text-sm font-medium text-gray-700 mb-1">Manager</label>
        {isManagerError ? (
          <div className="text-sm text-red-500 p-2 border border-red-300 rounded-md bg-red-50">
              Error loading managers. Cannot assign or change manager at this time.
          </div>
        ) : (
          <>
            {initialManagerId ? ( // Display if manager was set initially
              <div className="mb-2 p-2 border border-gray-200 rounded-md bg-gray-50 text-sm text-gray-800">
                {currentManagerName}
                {/* Optionally add a button here to allow changing the manager if needed */}
                {/* <button type="button" onClick={() => setInitialManagerId(null)}>Change Manager</button> */}
              </div>
            ) : ( // Allow selection only if no manager initially
              <select
                id="manager_id"
                name="manager_id_id"
                value={formData.manager_id_id || ""}
                onChange={handleChange}
                className="border border-gray-300 rounded-md p-2 w-full shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                // Required only if creating a new profile and no manager is selected yet
                required={!isUpdateMode && !formData.manager_id_id}
              >
                <option value="">Select a manager (Optional)</option>
                {allManagers.map((manager) => (
                  <option key={manager.id} value={manager.id}>
                    {manager.name}
                  </option>
                ))}
              </select>
            )}
          </>
        )}
      </div>

      {/* Action Buttons */}
      <div className="flex justify-between items-center mt-6 pt-4 border-t">
         {/* Left side buttons (Cancel/Delete) */}
         <div className="flex gap-2">
             {/* Conditionally render Cancel button if handler is provided */}
             {onCancel && (
                 <button
                     type="button"
                     onClick={onCancel}
                     className="bg-gray-200 text-gray-700 rounded-md py-2 px-4 text-sm font-medium hover:bg-gray-300 disabled:opacity-50"
                     disabled={isSubmitting || isDeleting}
                 >
                     Cancel
                 </button>
             )}
             {/* Show delete button only if in update mode */}
             {isUpdateMode && (
                 <button
                     type="button"
                     onClick={handleDelete}
                     className="bg-red-600 text-white rounded-md py-2 px-4 text-sm font-medium hover:bg-red-700 disabled:opacity-50"
                     disabled={isDeleting || isSubmitting}
                 >
                     {isDeleting ? "Deleting..." : "Delete Profile"}
                 </button>
             )}
         </div>

         {/* Right side button (Submit) */}
         <button
             type="submit"
             className="bg-indigo-600 text-white rounded-md py-2 px-4 text-sm font-medium hover:bg-indigo-700 disabled:opacity-50"
             // Disable during actions or if managers failed to load (unless displaying existing manager)
             disabled={isSubmitting || isDeleting || (isManagerError && !initialManagerId)}
         >
             {isSubmitting
                 ? "Submitting..."
                 : isUpdateMode
                 ? "Update Profile"
                 : "Create Profile"}
         </button>
      </div>
    </form>
  );
}
